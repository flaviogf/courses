#+TITLE: Effective go
#+AUTHOR: flaviogf
#+DATE: [2022-10-16 Sun]

+ Go is a new language, although it borrows ideas from existing languages
+ To write Go well, it's important to understand its properties and idioms
+ It's also important to know the established convetions for programming in Go

* Examples
+ The go package sources are intended to server not only as the core library but also as examples of how to use the language

* Formatting
+ With Go the machine take care of most formatting issues
+ The gofmt operates at the package level rather than source file level, it reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining an if necessary reformatting comments
+ All Go code in the standard packages has been formatted with gofmt
+ Indentation
+ Line length
+ Parentheses

* Commentary
+ Go provides C-style //**// block comments and C++-stule // line comments
+ Line comments are the norm
+ Block comments appear mostly as package comments
+ Comments that appear before top-level declarations, with no intervening newlines, are considered to document the declaration itself
+ These doc comments are the primary documentation for a given Go package or command

* Names
+ Names are as important in Go as in any other language
+ They even have semantic effect
+ The visibility of a name outsied a package is determined by whether its first character is upper case

** Package names
+ When a package is imported, the package name becomes an accessor for the contents
+ The package name should be good: short, concise, evocative
+ By convention, packages are give lower case, single-word names; there should be no need for underscores or mixedCaps
+ Don't worry about collisions, the package name is only the default name for imports; it need not be unique across all source code, and the importing package can choose a different name to use locally
+ Another convention is that the package name is the base name of its source directory
+ The importer of a package will use the name to refer to its content, so exported names in the package can use that fact to avoid repetition
+ Don't use the import . notation
+ For instance, the beffered reader type in the bufio package is called Reader, not BufReader, because users see it as bufio.Reader, which is clear, consice name
+ Because imported entities are always addressed with their package name, they don't conflict with each other
+ Similarly, the function to make new instances of ring.Ring --- wich is the definition of a constructor in go --- would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it's called just New, which clients of the package see as ring.New

** Getters
+ Go doesn't provide automatic support for getters and setters
+ There's nothing wrong with providing getters and setters yourself, and it's often approprieate to do so
+ But it's neither idiomatic nor necessary to put Get into the getter's name
+ If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported) not GetOwner
+ The use of upper-case names for export provides the hook to discriminate the field from the method
+ A setter function, if needed, will likely be called SetOwner
+ Both names read well in practice

#+begin_src go
  owner := obj.Owner()

  if owner != user {
    obj.SetOwner(user)
  }
#+end_src

** Interface names
+ By convetion, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc

** MixedCaps
+ Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names

** Semicolons
+ Like C, Go's formal grammar uses semicolon to terminate statements
+ But unlike C those semicolons do not appear in the source
+ Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them
+ The rule is this, if the last token before a newline is a identifier the lexer always insert a semicolon after the token
+ Idiomatica Go programs have semicolons only in places such as for loops clauses, to separete the initializer, condition, and continuation elements
+ They are also necessary to separte multiple statements on a line
+ One consequence of the semicolon insertion rule is that you cannot put the opening brace of a control structure on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects

** Control structure
+ The control structures of Go are related to those of C but differ in important ways
+ There is no do or while loop, only a slightly generalized for; switch is more flexible; if and switch accept an optional initialization statement like that of for; break and continue take an optional label to identify what to break or continue
+ And there are a new control structure including type switch and a multiway communications multiplexer, select
+ The syntax is also slightly different; there are no parentheses and the bodies must always be brace-delimited

#+begin_src go
  if x > 0 {
  }
#+end_src

+ Mandatory braces encourage writing simple if statements on multiple lines
+ It's good style to do so anyway, especialy when the body contains a control statement such as return or break
+ Since if and switch accept an initialization statement, it's common to see one used to set up a local variable

#+begin_src go
  if err := file.Chmod(0644); err != nil {
    log.Print(err)
    return
  }
#+end_src

+ In the Go libraries, you'll find that when an if statement doesn't flow into the next statement, that is, the body ends in break, continue, goto, or return the unnecessary else is ommited

#+begin_src go
  f, err := os.Open(name)

  if err != nil {
    return err
  }

  codeUsing(f)
#+end_src

** Redeclaration and reassignment
+ It's worth to nothing that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body

** For
+ The Go for loop is similar to but not the same as C's
+ It unifies for and while and there is no do-while
+ There are three forms, only one of wich has semicolons

+ Like a C for
#+begin_src go
  for init; condition; post { }
#+end_src

+ Like a C while
#+begin_src go
  for condition { }
#+end_src

+ Like a C for(;;)
#+begin_src go
  for { }
#+end_src

+ Short declarations make it easy to declare the index variable right in the loop
#+begin_src go
  sum := 0
  for i := 0; i < 10; i++ {
    sum += i
  }
#+end_src

+ If your are looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop
#+begin_src go
  for key, value := range oldMap {
    newMap[key] = value
  }
#+end_src

+ If you only need the first item in the range (the key or index), drop the second
#+begin_src go
  for key := range m {
    if key.expired() {
      delete(m, key)
    }
  }
#+end_src

+ If you only need the second item in the range (the value), use the blank identifier, an underscore, to discard the first
#+begin_src go
  sum := 0
  if _, value := range array {
    sum += value
  }
#+end_src

+ For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8
+ The name with the associate builtin type rune is Go terminology for single Unicode code point
+ Finally Go has no comma operator and ++ and -- are statements not expressions

** Switch
+ Go's switch is more general than C's
+ The expressions need not to be constants or even integers
+ The cases are evaluated top to bottom until a match is found
+ And if the switch has no expression it switchs on true
+ It's therefore possible and idiomatic to write an if-else-if-else chains as a switch

#+begin_src go
  func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
      return c - '0'
    case 'a' <= c && c <= 'f':
      return c - 'a' + 10
    case 'A' <= c && c <= 'F':
      return c - 'A' + 10
    }

    return 0
  }
#+end_src

+ There is no automatic fall through, but cases can be presented in comma-separated lists
#+begin_src go
  func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
      return true
    }

    return false
  }
#+end_src

+ Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early
+ Sometimes, though, it's necessary to break out of a surroundin loop, not the switch, and in Go that can be accomplished by putting a label on the loop and "breaking" to that label

#+begin_src go
  Loop:
      for n := 0; n < len(src); n += size {
        switch {
          case src[n] < sizeOne:
            if validateOnly {
              break
            }
            size = 1
            update(src[n])
          case src[n] < sizeTwo:
            if n+1 >= len(src) {
              err = errShortInput
              break Loop
            }

            if validateOnly {
              break
            }
            size = 2
            update(src[n] + src[n+1]<<shift)
        }
      }
#+end_src
